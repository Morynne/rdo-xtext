<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../scripts/thirdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../scripts/thirdparty/jquery-2.1.4.min.js"></script>
<script src="../scripts/table_of_contents.js"></script>
</head>
<body>
<h2>Образцы</h2>
<p>Образцы формируют часть базы знаний модели, позволяющую реализовать подход сканирования активностей. Образцы представляют собой набор правил и предусловий их выполнения, изменяющих состояние модели.</p>
<p>Описание образцов имеет следующий вид:</p>
<pre><code class="rao"><i>тип_образца</i> <i>имя_образца</i>(<i>описание_параметров_образца</i>) {
    <i>описание_релевантных_ресурсов_образца</i>
    <i>тело_образца</i>
}</code></pre>
<p>Определены образцы двух типов:</p>
<table style="width:100%">
    <tr>
        <th width="20%">Тип образца</th>
        <th width="80%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">operation</code></pre></td>
        <td>Описывают модифицированные продукционные правила, учитывающие временные связи</td>
    </tr>
    <tr>
        <td><pre><code class="rao">rule</code></pre></td>
        <td>Описывают обычные продукционные правила</td>
    </tr>
</table>
<h3>Условие запуска</h3>
<p>Образец может быть запущен в результате успешного подбора всех описанных в нем релевантных ресурсов. Конструкция подбора каждого релевантного ресурса одинакова для всех типов образцов и имеет следующий вид:</p>
<pre><code class="rao">relevant <i>имя_релевантного_ресурса</i> = <i>правило_подбора_ресурса</i></code></pre>
<p>Подбор релевантных ресурсов осуществляется с помощью метода <code class="rao">select(<i>условие_подбора_ресурса</i>)</code>. В случае, если метод вызывается у конкретного ресурса, этот ресурс подбирается как релевантный, только если его состояние удовлетворяет указанному условию. Если метод вызывается у типа ресурса, то отбираются все ресурсы данного типа, удовлетворяющие условию. Если условие не играет значения, то используется ключевое слово <code class="rao">any</code>. Выбор единственного ресурса из отобранной группы осуществляется с помощью следующих методов:</p>
<table style="width:100%">
    <tr>
        <th width="40%">Имя метода</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">first()</code></pre></td>
        <td>Выбор первого ресурса из группы</td>
    </tr>
    <tr>
        <td><pre><code class="rao">withMin(<i>арифметическое_выражение</i>)</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наименьшее значение</td>
    </tr>
    <tr>
        <td><pre><code class="rao">withMax(<i>арифметическое_выражение</i>)</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наибольшее значение</td>
    </tr>
</table>
<p>В случае, если не один из методов явно не вызван, по умолчанию выбирается первый ресурс из группы.</p>
<p>Пусть определены следующие типы ресурсов:</p>
<pre><code class="rao">enum Состояние_станка {свободен, загружается, готов_к_обработке,
        работает, разгружается, закончил_обработку, требует_переналадки, требует_ремонта}

enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}

type Станок {
    int номер;
    Состояние_станка состояние;
}

type Деталь {
    int номер;
    int этап_обработки;
    Состояние_детали состояние;
    double длительность_обработки;
}</code></pre>
<p>Тогда подбор релевантных ресурсов по различным признакам может иметь вид:</p>
<pre><code class="rao">operation этап_обработки_1() {
    // подбор станка номер 1 только если он свободен
    relevant исполнительный_станок_1 = станок_1.select(состояние == Состояние_станка.свободен);

    // подбор любого токарного станка из имеющихся - fist обязательно
    relevant исполнительный_станок_2 = Станок.select(any);

    // подбор любого свободного станка
    relevant исполнительный_станок_3 = Станок.select(состояние == Состояние_станка.свободен).first();

    // подбор детали, ожидающей обработки, с минимальной длительностью обработки
    relevant деталь = Деталь.select(состояние == Состояние_детали.ожидает_обработки).withMin(длительность_обработки);

    // описание тела образца
    // ...
}
</code></pre>
<p>Релевантные ресурсы выбираются последовательно и без возвращений, т.е. выбранный ресурс не может быть перевыбран. Это может привести к проблеме: при подборе следующего ресурса окажется, что образец не может быть выполнен из-за неудачного подбора предыдущего. Чтобы избежать подобного, процедура подбора должна проанализировать все возможные комбинации. Для этого используется конструкция <code class="rao">relevantSet</code>. Конечно, это приводит к падению быстродействия.<br>Пусть модель задана следующими ресурсами:</p>
<pre><code class="rao">enum Тип_обработки {токарная, фрезерная}
enum Состояние_станка {свободен, загружается, готов_к_обработке,
        работает, разгружается, закончил_обработку, требует_переналадки, требует_ремонта}
enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}

type Станок {
    Тип_обработки тип_обработки;
    Состояние_станка состояние;
}

type Деталь {
    Тип_обработки тип_обработки;
    Состояние_детали состояние;
    double время_обработки;
}

Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 10);
Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 20);
Деталь.create(Тип_обработки.фрезерная, Состояние_детали.ожидает_обработки, 40);

Станок.create(Тип_обработки.токарная, Состояние_станка.свободен);
Станок.create(Тип_обработки.фрезерная, Состояние_станка.свободен);</code></pre>
<p>В образце обработки требуется подобрать деталь с наименьшим временем обработки и подходящий для ее обработки станок.<br>Указание способа подбора для каждого ресурса отдельно:</p>
<pre><code class="rao">operation обработка() {
    relevant деталь = Деталь.select(состояние == Состояние_детали.ожидает_обработки).withMin(время_обработки);
    relevant станок = Станок.select(тип_обработки == деталь.тип_обработки
            &#38;&#38; состояние == Состояние_станка.свободен);

    // описание тела образца
    // на время обработки станку выставляется состояние "работает"
    // детали выставляется состояние "обрабатывается"
}</code></pre>
<p>При первом подборе ресурсов в приведенном выше образце будет выбрана деталь, требующая токарной обработки, со временем обработки равным 10 и токарный станок. При втором подборе окажется, что минимальное время обработки имеет оставшаяся из деталей, требующая токарной обработки. Однако токарный станок уже занят и условие <code class="rao">тип_обработки == деталь.тип_обработки</code> выполнено не будет. Несмотря на то, что в наличии есть ожидающая деталь, требующая фрезерной обработки, и фрезерный станок, образец выполнен не будет.<br>Подбор ресурсов из всех возможных комбинаций позволит избежать этой ситуации:</p>
<pre><code class="rao">operation обработка() {
    relevant деталь = Деталь.select(состояние == Состояние_детали.ожидает);
    relevant станок = Станок.select(тип_обработки == деталь.тип_обработки
            &#38;&#38; состояние == Состояние_станка.свободен);

    relevantSet withMin(деталь.время_обработки);

    // описание тела образца
    // на время обработки станку выставляется состояние "работает"
    // детали выставляется состояние "обрабатывается"
}</code></pre>
<p>В этом случае сначала будут подобраны все возможные пары станка и детали, а затем будет выбрана та из них, для которой время обработки детали минимально.</p>
<h3>Образцы типа operation</h3>
<p>В теле образцов типа <code class="rao">operation</code> описываются инструкции, выполняемые в начале и в конце операции, а также вычисление ее длительности. Для этого для операции задаются три метода:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">duration()</code></pre></td>
        <td>Задание длительности выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">begin()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в начале выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">end()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в конце выполнения операций</td>
    </tr>
</table>
<pre><code class="rao">operation этап_обработки_2() {
    relevant исполнительный_станок_1 = Станок.select(состояние == Состояние_станка.свободен).first();
    relevant обрабатываемая_деталь = Деталь.select(этап_обработки == 2 &#38;&#38; состояние == Состояние_детали.ожидает_обработки);

    set duration() {
        return обрабатываемая_деталь.длительность_обработки;
    }

    set begin() {
        обрабатываемая_деталь.состояние = Состояние_детали.обрабатывается;
        исполнительный_станок_1.состояние = Состояние.работает;
    }

    set end() {
        исполнительный_станок_1.состояние = Состояние.свободен;
        обрабатываемая_деталь.состояние = Состояние_детали.обработана;
    }
}</code></pre>
<p>Если длительность не задана, она принимается равной нулю. Если не заданы методы <code class="rao">begin</code> или <code class="rao">end</code>, то в начале и в конце операции соответственно состояние модели не меняется.</p>
<h3>Образцы типа rule</h3>
<p>В теле образцов типа <code class="rao">rule</code> определяется один метод:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">execute()</code></pre></td>
        <td>Описание инструкций, которые должны быть выполнены в момент выполнения образца</td>
    </tr>
</table>
<pre><code class="rao">rule вывоз_обработанных_деталей() {
    relevant обработанная_деталь = Деталь.select(этап_обработки == 3 &#38;&#38; состояние == Состояние_детали.обработана);

    set execute() {
        обработанная_деталь.erase();
    }
}</code></pre>
</body>
</html>
